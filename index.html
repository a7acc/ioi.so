<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>æ—¥æ–‡å¸¸ç”¨èªç·´ç¿’ï¼ˆå‹•æ…‹è¼‰å…¥ï¼‰</title>
  <!--
    æ³¨æ„ï¼šè«‹é€é HTTP ä¼ºæœå™¨æˆ– GitHub Pages åŸ·è¡Œæœ¬æª”ï¼Œ
    ä¸¦ç¢ºä¿ API æ”¯æ´ CORSï¼Œå¦å‰‡éœ€ä½¿ç”¨ä»£ç†ä»¥é¿å…è¢«é˜»æ“‹ã€‚
  -->
  <style>
    body { font-family: sans-serif; text-align: center; padding: 2em; }
    #phrase { font-size: 2em; margin: 1.5em 0; }
    #translation { font-size: 1.5em; color: #555; min-height: 1.2em; margin-top: 0.5em; visibility: hidden; }
    #error { color: red; margin-top: 1em; white-space: pre-wrap; }
    button { font-size: 1em; padding: 0.5em 1em; margin: 0 0.3em; cursor: pointer; }
  </style>
</head>
<body>
  <h1>æ¯æ—¥ã®æ—¥æœ¬èªãƒ•ãƒ¬ãƒ¼ã‚º</h1>
  <div id="phrase">è¼‰å…¥ä¸­â€¦</div>
  <div id="translation"></div>
  <div id="error"></div>

  <button id="speakBtn">ğŸ”Š ç™¼éŸ³</button>
  <button id="showCnBtn">ç¹é«”ä¸­æ–‡</button>
  <button id="nextBtn">â–¶ï¸ ä¸‹ä¸€å¥</button>

  <script>
    const phraseEl      = document.getElementById("phrase");
    const translationEl = document.getElementById("translation");
    const errorEl       = document.getElementById("error");
    const speakBtn      = document.getElementById("speakBtn");
    const showCnBtn     = document.getElementById("showCnBtn");
    const nextBtn       = document.getElementById("nextBtn");

    let currentPhrase = "";
    let currentTrans  = null;
    // éœæ…‹å‚™æ´å¥å­
    const staticPhrases = [
      "ã“ã‚“ã«ã¡ã¯", "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™", "ã“ã‚“ã°ã‚“ã¯",
      "ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™", "ã™ã¿ã¾ã›ã‚“", "ã„ãŸã ãã¾ã™"
    ];
    let fallbackIndex = 0;

    // å˜—è©¦ç›´æ¥ fetchï¼Œå†ä½¿ç”¨ AllOrigins ä»£ç†
    async function fetchRandomPhrase() {
      const endpoint = 'https://tatoeba-scraper.herokuapp.com/random/?lang=jpn';
      try {
        // 1. ç›´æ¥è«‹æ±‚
        let res = await fetch(endpoint);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        let data = await res.json();
        const item = Array.isArray(data) ? data[0]
                     : (data.sentences ? data.sentences[0] : data);
        return item.text || '';
      } catch (e) {
        console.warn('ç›´æ¥è¼‰å…¥å¤±æ•—:', e.message);
        // 2. ä»£ç†è«‹æ±‚
        try {
          const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(endpoint);
          let res2 = await fetch(proxyUrl);
          if (!res2.ok) throw new Error(`ä»£ç† HTTP ${res2.status}`);
          let data2 = await res2.json();
          const item2 = Array.isArray(data2) ? data2[0]
                       : (data2.sentences ? data2.sentences[0] : data2);
          return item2.text || '';
        } catch (e2) {
          console.error('ä»£ç†è¼‰å…¥å¤±æ•—:', e2.message);
          errorEl.textContent = `ç„¡æ³•è¼‰å…¥ç¶²è·¯å¥å­: ${e2.message}\nå°‡ä½¿ç”¨å…§å»ºç¯„ä¾‹ã€‚`;
          const text = staticPhrases[fallbackIndex % staticPhrases.length];
          fallbackIndex++;
          return text;
        }
      }
    }

    async function showPhrase() {
      errorEl.textContent = '';
      currentTrans = null;
      translationEl.style.visibility = 'hidden';
      translationEl.textContent = '';
      phraseEl.textContent = 'è¼‰å…¥ä¸­â€¦';
      currentPhrase = await fetchRandomPhrase();
      phraseEl.textContent = currentPhrase;
    }

    function speakPhrase() {
      const utt = new SpeechSynthesisUtterance(currentPhrase);
      utt.lang = 'ja-JP';
      const voice = speechSynthesis.getVoices().find(v => v.lang.startsWith('ja'));
      if (voice) utt.voice = voice;
      speechSynthesis.speak(utt);
    }

    async function fetchTranslation() {
      try {
        const url = 'https://api.mymemory.translated.net/get'
                  + '?q=' + encodeURIComponent(currentPhrase)
                  + '&langpair=ja|zh-TW';
        const res = await fetch(url);
        const js  = await res.json();
        return js.responseData?.translatedText || 'ç¿»è­¯å¤±æ•—';
      } catch (e) {
        console.error('ç¿»è­¯è«‹æ±‚å¤±æ•—:', e.message);
        errorEl.textContent = `ç¿»è­¯è«‹æ±‚å¤±æ•—: ${e.message}`;
        return 'ç¿»è­¯å¤±æ•—';
      }
    }

    async function showTranslation() {
      if (currentTrans === null) {
        translationEl.textContent = 'ç¿»è­¯ä¸­â€¦';
        currentTrans = await fetchTranslation();
      }
      translationEl.textContent = currentTrans;
      translationEl.style.visibility = 'visible';
    }
    function hideTranslation() {
      translationEl.style.visibility = 'hidden';
    }

    nextBtn.addEventListener('click', showPhrase);
    speakBtn.addEventListener('click', speakPhrase);

    showCnBtn.addEventListener('mousedown', showTranslation);
    showCnBtn.addEventListener('mouseup',   hideTranslation);
    showCnBtn.addEventListener('mouseleave',hideTranslation);
    showCnBtn.addEventListener('touchstart',showTranslation);
    showCnBtn.addEventListener('touchend',  hideTranslation);

    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = () => {};
    }
    showPhrase();
  </script>
</body>
</html>
