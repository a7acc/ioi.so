<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>æ—¥æ–‡å¸¸ç”¨èªç·´ç¿’ï¼ˆå‹•æ…‹è¼‰å…¥ï¼‰</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 2em;
    }
    #phrase {
      font-size: 2em;
      margin: 1.5em 0;
    }
    #translation {
      font-size: 1.5em;
      color: #555;
      min-height: 1.2em;
      margin-top: 0.5em;
      visibility: hidden;
    }
    button {
      font-size: 1em;
      padding: 0.5em 1em;
      margin: 0 0.3em;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <h1>æ¯æ—¥ã®æ—¥æœ¬èªãƒ•ãƒ¬ãƒ¼ã‚º</h1>
  <div id="phrase">è¼‰å…¥ä¸­â€¦</div>
  <div id="translation"></div>

  <button id="speakBtn">ğŸ”Š ç™¼éŸ³</button>
  <button id="showCnBtn">ğŸ‡¨ğŸ‡³ é¡¯ç¤ºä¸­æ–‡</button>
  <button id="nextBtn">â–¶ï¸ ä¸‹ä¸€å¥</button>

  <script>
    const phraseEl      = document.getElementById("phrase");
    const translationEl = document.getElementById("translation");
    const speakBtn      = document.getElementById("speakBtn");
    const showCnBtn     = document.getElementById("showCnBtn");
    const nextBtn       = document.getElementById("nextBtn");

    let currentPhrase = "";      // ç•¶å‰æ—¥æ–‡å¥å­
    let currentTrans  = null;    // ç•¶å‰ä¸­æ–‡ç¿»è­¯ï¼ˆnull è¡¨ç¤ºå°šæœªå–å¾—ï¼‰

    // å–éš¨æ©Ÿæ—¥æ–‡å¥å­
    async function fetchRandomPhrase() {
      try {
        const res = await fetch(
          "https://tatoeba-scraper.herokuapp.com/random/?lang=jpn"
        );
        const data = await res.json();
        // è‹¥ API å›ä¸€ç­† objectï¼Œå¯èƒ½ç‚º data.sentences[0] æˆ– data[0]ï¼Œæ­¤è™•å˜—è©¦å…¼å®¹
        const item = Array.isArray(data) ? data[0]
                     : (data.sentences ? data.sentences[0] : data);
        return item.text || "";
      } catch (e) {
        console.error(e);
        return "è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚";
      }
    }

    // é¡¯ç¤ºæ–°å¥å­
    async function showPhrase() {
      currentTrans = null;
      translationEl.style.visibility = "hidden";
      translationEl.textContent = "";

      phraseEl.textContent = "è¼‰å…¥ä¸­â€¦";
      const text = await fetchRandomPhrase();
      currentPhrase = text;
      phraseEl.textContent = text;
    }

    // èªéŸ³æœ—è®€
    function speakPhrase() {
      const utt = new SpeechSynthesisUtterance(currentPhrase);
      utt.lang = "ja-JP";
      const voice = speechSynthesis.getVoices()
                     .find(v => v.lang.startsWith("ja"));
      if (voice) utt.voice = voice;
      speechSynthesis.speak(utt);
    }

    // å–ä¸­æ–‡ç¿»è­¯ï¼ˆMyMemory APIï¼‰
    async function fetchTranslation() {
      const url = "https://api.mymemory.translated.net/get"
                + "?q=" + encodeURIComponent(currentPhrase)
                + "&langpair=ja|zh-TW";
      try {
        const res = await fetch(url);
        const js  = await res.json();
        // ä¸»ç¿»è­¯çµæœé€šå¸¸åœ¨ responseData.translatedText
        return js.responseData?.translatedText || "ç¿»è­¯å¤±æ•—";
      } catch (e) {
        console.error(e);
        return "ç¿»è­¯å¤±æ•—";
      }
    }

    // é¡¯ç¤ºç€è¦½æ™‚å³æ™‚ç¿»è­¯
    async function showTranslation() {
      if (currentTrans === null) {
        translationEl.textContent = "ç¿»è­¯ä¸­â€¦";
        currentTrans = await fetchTranslation();
      }
      translationEl.textContent = currentTrans;
      translationEl.style.visibility = "visible";
    }

    function hideTranslation() {
      translationEl.style.visibility = "hidden";
    }

    // ç¶å®šäº‹ä»¶
    nextBtn.addEventListener("click", showPhrase);
    speakBtn.addEventListener("click", speakPhrase);

    showCnBtn.addEventListener("mousedown", showTranslation);
    showCnBtn.addEventListener("mouseup",   hideTranslation);
    showCnBtn.addEventListener("mouseleave",hideTranslation);
    showCnBtn.addEventListener("touchstart",showTranslation);
    showCnBtn.addEventListener("touchend",  hideTranslation);

    // åˆå§‹è¼‰å…¥
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = () => {};
    }
    showPhrase();
  </script>

</body>
</html>
